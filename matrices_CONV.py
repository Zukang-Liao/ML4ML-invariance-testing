# To save variance matrices at CONV level at args.plot_dir
# Input: load the .npy file (test_actoverall1515.npy) generated by save_invariance_results.py
# Output: variance matrices
# Please specify --data_dir (where the .npy files are saved)
# The variance matrix plots will be generated in the same directory

import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
import collections
from utils import verify_paths, get_relations, merge_relations, get_asymmetry, get_continuity
from datamat import load_actoverall

import warnings
warnings.filterwarnings("ignore")

def argparser():
    parser = argparse.ArgumentParser()
    # The directory where the test_actoverall1515.npy file is
    parser.add_argument("--data_dir", type=str, default="/datadir")
    # if you have specify other filename generated by save_invariance_results.py, please specify the generated filename here.
    parser.add_argument("--data_filename", type=str, default="")
    # if you have generated test_actoverallxxxx.npy for other testing interval, rather than [-15, 15], please specify here.
    parser.add_argument("--plot_foldername", type=str, default="1515")

    # You must specify:
    parser.add_argument("--mid", type=str, default="-1") # model id
    # "r": rotation, "b": brightness, "s": scaling
    parser.add_argument("--aug_type", type=str, default="r")

    # Optonal:
    # If we split the data into correcly classified and misclassified examples
    parser.add_argument("--correct_split", type=bool, default=True)
    # If correct_split, whether we make the two splits the same number of data objects.
    parser.add_argument("--equal_split", type=bool, default=False)
    
    # Fixed parameters for this work:
    parser.add_argument("--seed", type=int, default=2)
    parser.add_argument("--flip_y", type=bool, default=True)
    parser.add_argument("--plot_detail", type=bool, default=False)
    parser.add_argument("--l2_norm", type=bool, default=True)
    parser.add_argument("--r", type=float, default=1.0) # ratio of data used
    parser.add_argument("--adv", type=bool, default=False)
    parser.add_argument("--epsilon", type=float, default=0.0)
    # Testing suite is either testing set or training set of the original dataset (CIFAR or MNIST)
    # In this work we only consider "testing set" as the testing suite.
    parser.add_argument("--train", type=bool, default=False)

    args = parser.parse_args()
    set_default_filename(args)
    args.data_path = os.path.join(args.data_dir, str(args.mid), args.data_filename)
    args.plot_dir = os.path.join(args.data_dir, str(args.mid), args.plot_foldername)
    return args


def set_default_filename(args):
    if args.data_filename == "":
        if args.aug_type == "r":
            args.data_filename = "test_actoverall1515"
        else:
            args.data_filename = f"test_actoverall0515{args.aug_type}"
        if args.adv:
            args.data_filename += f"_adv{args.epsilon}"
            args.plot_foldername += f"_adv{args.epsilon}"
        args.data_filename += ".npy"
    if "t" in args.mid:
        args.data_dir = args.data_dir+"_t"


def plot_actoverall(args, class_id=None, test_intervals=None):
    # columns = ["idx", "label", "prediction", "f_idx", "mean", "std", "max", "min", "mean_max", "mean_std", "max_mean", "max_std", "angle"]
    verify_paths(args)
    if args.train:
        _file_ext = " train.jpg"
    else:
        _file_ext = " test.jpg"

    def _plot_metric(arr, plot_title, plot_name, feature_name, metrics, plot_sep=False):
        if args.flip_y:
            h, w = arr.shape
            plt.imshow(arr, extent=[0, w, 0, h])
        else:
            plt.imshow(arr)
        plt.tight_layout()
        plt.axes().set_aspect("equal")
        plt.title(plot_title)
        plt.colorbar()
        plot_dir = os.path.join(args.plot_dir, feature_name, metrics)
        if class_id is not None:
            plot_dir = os.path.join(plot_dir, f"Class{class_id}")
            plot_name = f"Class{class_id}_"+plot_name
        if plot_sep and args.plot_detail:
            if args.train:
                plot_dir = os.path.join(plot_dir, "incorr_corr_sep_train")
            else:
                plot_dir = os.path.join(plot_dir, "incorr_corr_sep_test")
        if not os.path.exists(plot_dir):
            os.makedirs(plot_dir)
        plt.savefig(os.path.join(plot_dir, plot_name))
        plt.clf()
        
    overall_stats = ["f_idx", "mean", "std", "max", "min", "mean_max", "mean_std", "max_mean", "max_std"]
    if args.correct_split:
        incorr_confidence, corr_confidence, test_intervals = load_actoverall(args, class_id, test_intervals)
        nb_angles = len(test_intervals)
        nb_incorr = incorr_confidence.shape[1]
        nb_corr = corr_confidence.shape[1]

        plot_title = f"\nIncorr (left):{nb_incorr}, corr (right):{nb_corr}"
        if class_id is not None:
            plot_title = f", class:{class_id}" + plot_title
        for f_idx in range(incorr_confidence.shape[2]):
            if incorr_confidence.shape[1] == 0:
                incorr_confidence = corr_confidence
            fn = f"Conv2d_{int(incorr_confidence[0, 0, f_idx, 0])}"
            for s_idx in range(1, len(overall_stats)):
                sn = overall_stats[s_idx]
                corrcoefs, cos_dists, l2_dists = get_relations([incorr_confidence[:, :, f_idx, s_idx], corr_confidence[:, :, f_idx, s_idx]], l2_norm=args.l2_norm, flip_y=args.flip_y)
                # metric_names = ["corrcoef", "cos_dist", "l2_dist"]
                # for m_idx, metrics in enumerate([corrcoefs, cos_dists, l2_dists]):
                metric_names = ["l2_dist"]
                for m_idx, metrics in enumerate([l2_dists]):
                    mn = metric_names[m_idx]
                    ctny, asymm = get_continuity(metrics, args.flip_y), get_asymmetry(metrics, args.flip_y)
                    pt = plot_title + f"\nDiscontinuity: {ctny[0]:.3f}                  {ctny[1]:.3f}"
                    pt += f"\nAsymmetry: {asymm[0]:.3f}                {asymm[1]:.3f}"
                    merged = merge_relations([metrics], nb_angles)[0]
                    _plot_metric(merged, f"{fn} {sn}, {mn}, mid: {args.mid}"+pt, f"{fn}_{sn}_{mn}"+_file_ext, fn, mn)

                    if args.plot_detail:
                        diff = np.subtract(metrics[0], metrics[1])
                        _plot_metric(diff, f"diff_{sn}_{mn}"+plot_title, f"diff {sn}_{mn} {fn}"+_file_ext, fn, mn, plot_sep=True)
                        _pt = f"{fn} {sn}, {mn}\nAll {nb_incorr} incorrect examples, {mn}\nDiscontinuity: {ctny[0]:.3f}, asymmetry: {asymm[0]:.3f}"
                        _plot_metric(metrics[0], _pt, f"incorr_{fn} {sn} {mn}"+_file_ext, fn, mn, plot_sep=True)
                        _pt = f"{fn} {sn}, {mn}\nAll {nb_corr} correct examples, {mn}\nDiscontinuity: {ctny[1]:.3f}, asymmetry: {asymm[1]:.3f}"
                        _plot_metric(metrics[1], _pt, f"corr_{fn} {sn} {mn}"+_file_ext, fn, mn, plot_sep=True)
    else:
        data, test_intervals = load_actoverall(args, class_id, test_intervals)
        for f_idx in range(data.shape[2]):
            fn = f"Conv2d_{data[0, 0, f_idx, 0]}"
            for s_idx in range(1, len(overall_stats)):
                sn = overall_stats[s_idx]
                corrcoef, cos_dist, l2_dist = get_relations([data[:,:,f_idx,s_idx]], l2_norm=args.l2_norm, flip_y=args.flip_y)
                metric_names = ["corrcoef", "cos_dist", "l2_dist"]
                for m_idx, metrics in enumerate([corrcoef, cos_dist, l2_dist]):
                    mn = metric_names[m_idx]
                    _plot_metric(metrics[0], f"All {data.shape[1]} examples, {fn} {sn}, {mn}", f"all_example {fn}_{sn}_{mn}"+_file_ext, fn, mn, plot_sep=True)


if __name__ == "__main__":
    args = argparser()
    print(args)
    if args.aug_type == "r":
        test_intervals = [-15, 15]
        args.intv_centre = 0
    else:
        test_intervals=[0.7, 1.3]
        args.intv_centre = 1
    plot_actoverall(args, class_id=None, test_intervals=test_intervals)
